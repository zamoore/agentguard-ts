#!/usr/bin/env tsx
/**
 * Auto-generates src/version.ts with comprehensive package and build metadata
 *
 * This script:
 * - Reads package.json for package info
 * - Gets git information (hash, branch, tag)
 * - Includes build environment details
 * - Generates utility functions for version handling
 *
 * Usage: pnpm generate:version
 */

import { writeFileSync, readFileSync, existsSync } from 'fs';
import { execSync } from 'child_process';
import { join } from 'path';

interface PackageJson {
  name: string;
  version: string;
  description?: string;
  license?: string;
  author?: string | { name: string; email?: string };
  homepage?: string;
  repository?: string | { url: string };
}

interface GitInfo {
  gitHash: string;
  gitBranch: string;
  gitTag: string;
  gitRemote: string;
  isDirty: boolean;
}

interface BuildEnvironment {
  nodeVersion: string;
  npmVersion: string;
  platform: string;
  arch: string;
  timezone: string;
  buildTime: string;
  buildUser: string;
}

/**
 * Safely execute git commands and handle errors
 */
function safeExec(command: string, fallback: string = 'unknown'): string {
  try {
    return execSync(command, {
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'ignore'],
    }).trim();
  } catch {
    return fallback;
  }
}

/**
 * Get comprehensive git information
 */
function getGitInfo(): GitInfo {
  const gitHash = safeExec('git rev-parse --short HEAD', 'dev');
  const gitBranch = safeExec('git rev-parse --abbrev-ref HEAD', 'main');
  const gitTag = safeExec('git describe --tags --exact-match 2>/dev/null', '');
  const gitRemote = safeExec('git config --get remote.origin.url', '');

  // Check if working directory is dirty
  const gitStatus = safeExec('git status --porcelain', '');
  const isDirty = gitStatus.length > 0;

  return {
    gitHash: isDirty ? `${gitHash}-dirty` : gitHash,
    gitBranch,
    gitTag,
    gitRemote: gitRemote.replace(/\.git$/, ''),
    isDirty,
  };
}

/**
 * Get build environment information
 */
function getBuildEnvironment(): BuildEnvironment {
  const npmVersion = safeExec('npm --version', 'unknown');
  const buildUser = safeExec('git config user.name', process.env.USER || 'unknown');

  return {
    nodeVersion: process.version,
    npmVersion,
    platform: process.platform,
    arch: process.arch,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    buildTime: new Date().toISOString(),
    buildUser,
  };
}

/**
 * Read and validate package.json
 */
function getPackageInfo(): PackageJson {
  const packagePath = join(process.cwd(), 'package.json');

  if (!existsSync(packagePath)) {
    throw new Error('package.json not found in current directory');
  }

  try {
    const pkg: PackageJson = JSON.parse(readFileSync(packagePath, 'utf-8'));

    if (!pkg.name || !pkg.version) {
      throw new Error('package.json must contain name and version fields');
    }

    return pkg;
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error('package.json contains invalid JSON');
    }
    throw error;
  }
}

/**
 * Generate TypeScript content for version.ts
 */
function generateVersionContent(pkg: PackageJson, git: GitInfo, env: BuildEnvironment): string {
  const authorName = typeof pkg.author === 'string' ? pkg.author : pkg.author?.name || 'Unknown';

  return `/**
 * 🤖 AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * 
 * This file is automatically generated by scripts/generate-version.ts
 * 
 * Package: ${pkg.name} v${pkg.version}
 * Generated: ${env.buildTime}
 * Git: ${git.gitHash} (${git.gitBranch})
 * Node: ${env.nodeVersion}
 * Platform: ${env.platform} ${env.arch}
 */

// Package Information
export const name = '${pkg.name}'
export const version = '${pkg.version}'
export const description = '${pkg.description || ''}'
export const license = '${pkg.license || ''}'
export const author = '${authorName}'
export const homepage = '${pkg.homepage || ''}'

// Build Information
export const buildInfo = {
  buildTime: '${env.buildTime}',
  buildUser: '${env.buildUser}',
  nodeVersion: '${env.nodeVersion}',
  npmVersion: '${env.npmVersion}',
  platform: '${env.platform}',
  arch: '${env.arch}',
  timezone: '${env.timezone}',
} as const

// Git Information
export const gitInfo = {
  hash: '${git.gitHash}',
  branch: '${git.gitBranch}',
  tag: '${git.gitTag}',
  remote: '${git.gitRemote}',
  isDirty: ${git.isDirty},
} as const

// Environment Detection
export const isProduction = process.env.NODE_ENV === 'production'
export const isDevelopment = process.env.NODE_ENV === 'development'
export const isTest = process.env.NODE_ENV === 'test'

// Utility Functions
export function getVersionString(): string {
  const env = process.env.NODE_ENV || 'development'
  return \`\${name} v\${version} (\${env})\`
}

export function getFullVersionString(): string {
  const env = process.env.NODE_ENV || 'development'
  const gitSuffix = gitInfo.tag || gitInfo.hash
  return \`\${name} v\${version} (\${env}) [\${gitSuffix}]\`
}

export function getBuildString(): string {
  return \`Built \${buildInfo.buildTime} by \${buildInfo.buildUser}\`
}

/**
 * Compare version with another semantic version string
 * Returns: 1 if current > compare, -1 if current < compare, 0 if equal
 */
export function compareVersion(compareVersion: string): number {
  const [major = 0, minor = 0, patch = 0] = version.split('.').map(v => parseInt(v, 10) || 0)
  const [cMajor = 0, cMinor = 0, cPatch = 0] = compareVersion.split('.').map(v => parseInt(v, 10) || 0)
  
  if (major > cMajor) return 1
  if (major < cMajor) return -1
  if (minor > cMinor) return 1
  if (minor < cMinor) return -1
  if (patch > cPatch) return 1
  if (patch < cPatch) return -1
  return 0
}

/**
 * Check if current version is greater than compare version
 */
export function isVersionGreaterThan(otherVersion: string): boolean {
  return compareVersion(otherVersion) > 0
}

/**
 * Check if current version satisfies a semver range (basic implementation)
 */
export function satisfiesVersion(range: string): boolean {
  // Basic implementation - in real apps you might use 'semver' package
  if (range.startsWith('>=')) {
    return compareVersion(range.slice(2)) >= 0
  }
  if (range.startsWith('>')) {
    return compareVersion(range.slice(1)) > 0
  }
  if (range.startsWith('<=')) {
    return compareVersion(range.slice(2)) <= 0
  }
  if (range.startsWith('<')) {
    return compareVersion(range.slice(1)) < 0
  }
  if (range.startsWith('=') || range.startsWith('==')) {
    return compareVersion(range.replace(/^==?/, '')) === 0
  }
  
  // Exact match
  return version === range
}

/**
 * Get comprehensive version info object
 */
export function getVersionInfo() {
  return {
    package: {
      name,
      version,
      description,
      license,
      author,
      homepage,
    },
    build: buildInfo,
    git: gitInfo,
    environment: {
      isProduction,
      isDevelopment,
      isTest,
      nodeEnv: process.env.NODE_ENV || 'development',
    },
    strings: {
      version: getVersionString(),
      fullVersion: getFullVersionString(),
      build: getBuildString(),
    },
  } as const
}

// Default export for convenience
export default {
  name,
  version,
  buildInfo,
  gitInfo,
  getVersionString,
  getFullVersionString,
  getBuildString,
  compareVersion,
  isVersionGreaterThan,
  satisfiesVersion,
  getVersionInfo,
}
`;
}

/**
 * Main generation function
 */
function generateVersion(): void {
  console.log('🔧 Generating version.ts...');

  try {
    const pkg = getPackageInfo();
    const git = getGitInfo();
    const env = getBuildEnvironment();

    const content = generateVersionContent(pkg, git, env);
    const outputPath = join(process.cwd(), 'src', 'version.ts');

    writeFileSync(outputPath, content, 'utf-8');

    console.log('✅ Generated src/version.ts');
    console.log(`   📦 Package: ${pkg.name} v${pkg.version}`);
    console.log(
      `   🌿 Git: ${git.gitHash} (${git.gitBranch})${git.gitTag ? ` [${git.gitTag}]` : ''}`,
    );
    console.log(`   🏗️  Build: ${env.buildTime}`);
    console.log(`   🖥️  Environment: Node ${env.nodeVersion} on ${env.platform}`);

    if (git.isDirty) {
      console.log('   ⚠️  Warning: Working directory has uncommitted changes');
    }
  } catch (error) {
    console.error('❌ Failed to generate version.ts:');
    console.error(error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

// Run the generation if this script is executed directly
// In ES modules, we check if the script was imported vs executed
if (import.meta.url === `file://${process.argv[1]}`) {
  generateVersion();
}

export { generateVersion };
